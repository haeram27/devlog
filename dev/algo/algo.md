# Algorithm

## [그리디 (greedy)](https://namu.wiki/w/%EA%B7%B8%EB%A6%AC%EB%94%94%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

## [분할 정복 (divide and conquer)](https://namu.wiki/w/%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

## [동적 계획법 (DP)](https://namu.wiki/w/%EB%8F%99%EC%A0%81%20%EA%B3%84%ED%9A%8D%EB%B2%95)

## `분할정복` vs `동적계획법`

분할 정복(Divide and Conquer)과 동적 계획법(Dynamic Programming, DP)은 큰 문제를 작은 문제로 나누어 푼다는 공통점이 있지만, **작은 문제를 다루는 방식**에서 근본적인 차이가 있습니다.

### 핵심 아이디어 요약

- **분할 정복 (Divide and Conquer):** "각자 알아서 해, 나중에 합치자!"
  - 큰 문제를 **서로 독립적인(disjoint)** 작은 문제들로 나눕니다.
  - 각 작은 문제들을 재귀적으로 푼 뒤, 그 해답들을 합쳐서 원래 문제의 답을 구합니다.
  - **예시:** CEO가 A 부서와 B 부서에 **서로 다른 일**을 맡기고, 나중에 보고서를 취합하는 방식.

- **동적 계획법 (Dynamic Programming):** "이거 나중에 또 써야 하니까, 기록해두자!"
  - 큰 문제를 나누었을 때, 그 작은 문제들이 **서로 중복되는(overlapping)** 경우에 사용합니다.
  - 가장 작은 문제부터 차례대로 푼 뒤, 그 해답을 **저장(Memoization 또는 Tabulation)**해 둡니다.
  - 나중에 동일한 작은 문제가 나타나면 다시 계산하지 않고 저장된 답을 즉시 사용합니다.
  - **예시:** 1층부터 차근차근 벽돌을 쌓아 올리며 건물을 짓는 방식. 10층을 지으려면 9층까지 지어져 있어야 합니다.

---

### 주요 차이점 비교

| 구분 | 분할 정복 (Divide and Conquer) | 동적 계획법 (Dynamic Programming) |
| :--- | :--- | :--- |
| **하위 문제의 관계** | **서로 독립적 (Independent Subproblems)**<br>하위 문제 간에 공통 부분이 없음 | **서로 중복됨 (Overlapping Subproblems)**<br>동일한 하위 문제가 반복적으로 나타남 |
| **문제 해결 방식** | **Top-down (하향식)**<br>큰 문제에서 작은 문제로 재귀 호출 | **Bottom-up (상향식) 또는 Top-down**<br>작은 문제부터 풀어 테이블을 채우거나(Tabulation),<br>재귀에 캐시를 추가함(Memoization) |
| **핵심** | **분할(Divide)과 병합(Combine)**<br>문제를 잘 나누고, 결과를 잘 합치는 것이 중요 | **결과 저장 및 재활용**<br>한 번 푼 문제의 답을 저장하는 것이 핵심 |
| **주요 예시** | 병합 정렬(Merge Sort), 퀵 정렬(Quick Sort),<br>이진 탐색(Binary Search) | 피보나치 수열, 최장 공통 부분 수열(LCS),<br>배낭 문제(Knapsack Problem) |

---

### 예시로 보는 차이

#### 1. 분할 정복의 예: 병합 정렬 (Merge Sort)

`[8, 3, 6, 1, 7, 2, 5, 4]`를 정렬하는 경우:

1. **분할:** `[8, 3, 6, 1]`과 `[7, 2, 5, 4]` 두 개의 독립적인 문제로 나눕니다.
2. **정복:**
    - 왼쪽 배열을 정렬하는 것과 오른쪽 배열을 정렬하는 것은 **서로 아무런 영향을 주지 않습니다.**
    - 왼쪽을 정렬하기 위해 또다시 `[8, 3]`과 `[6, 1]`로 나눕니다. 이 과정도 서로 독립적입니다.
3. **병합:** 정렬된 두 배열 `[1, 3, 6, 8]`과 `[2, 4, 5, 7]`을 합쳐 최종 결과 `[1, 2, 3, 4, 5, 6, 7, 8]`을 만듭니다.

**핵심:** 왼쪽 배열을 정렬할 때 풀었던 문제(예: `[8, 3]` 정렬)는 오른쪽 배열을 정렬할 때 다시 필요하지 않습니다.

#### 2. 동적 계획법의 예: 피보나치 수열

`fib(5)`를 구하는 경우:

1. **분할:** `fib(5)`는 `fib(4) + fib(3)`으로 나눌 수 있습니다.
2. `fib(4)`는 `fib(3) + fib(2)`로 나눌 수 있습니다.
3. **문제 발견:** `fib(5)`를 구하는 데 `fib(3)`이 필요하고, `fib(4)`를 구하는 데도 `fib(3)`이 또 필요합니다. **`fib(3)`이라는 하위 문제가 중복됩니다.**

**DP의 해결책:**

1. `fib(0)`, `fib(1)`부터 계산을 시작합니다.
2. `fib(2)`를 계산하고 그 결과를 배열이나 맵에 저장합니다. `dp[2] = 1`
3. `fib(3)`을 계산하고 저장합니다. `dp[3] = 2`
4. `fib(4)`를 계산할 때, `fib(3)`과 `fib(2)`가 필요한데, 다시 계산하는 대신 저장해 둔 `dp[3]`과 `dp[2]` 값을 바로 가져와 사용합니다.

**핵심:** 중복되는 계산을 피하기 위해 한 번 푼 문제의 답을 기록하고 재활용합니다.

### 언제 무엇을 선택해야 할까?

1. 문제를 작은 문제로 나누었을 때, 그 **작은 문제들이 완전히 독립적인가?**
    - **예 → 분할 정복**

2. 문제를 작은 문제로 나누었더니, **똑같은 작은 문제가 계속해서 나타나는가?**
    - **예 → 동적 계획법**

## [Theory of computation](https://gazelle-and-cs.tistory.com/category/%EC%88%98%ED%95%99%EC%A0%81%20%EB%8F%84%EA%B5%AC/Theory%20of%20computation)

- [P vs NP](https://gazelle-and-cs.tistory.com/64)
- [NP-Complete](https://gazelle-and-cs.tistory.com/74)
