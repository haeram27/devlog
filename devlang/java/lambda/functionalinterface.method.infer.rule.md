# 함수형 인터페이스(SAM)와 메서드 매칭 규칙

* **Java 언어 명세의 메서드 시그니처**는 메서드 이름과 매개변수의 타입 및 순서를 포함하며, 메서드 오버로딩을 구분하는 데 사용됩니다.
* **함수형 인터페이스의 추론 규칙**은 메서드 이름을 고려하지 않고, 매개변수의 타입과 순서, 반환 타입의 호환성을 기반으로 람다 표현식이나 메서드 참조의 유효성을 판단합니다.

따라서, 함수형 인터페이스에서의 "추상 메서드 시그니처" 추론은 일반적인 Java 메서드 시그니처 개념과는 다른 맥락에서 이해되어야 합니다.

함수형 인터페이스 관련 문서에서 "추상 메서드 시그니처"라는 표현이 사용될 때,
이는 실제로는 **"해당 추상 메서드의 파라미터 및 반환 타입"** 을 의미하는 비공식적 표현입니다.
Java 명세에서 말하는 "method signature"와 구분해서 이해해야 합니다.

---

## Java 언어 명세에서의 메서드 시그니처

Java에서 **메서드 시그니처**는 메서드의 **이름**과 **매개변수의 타입 및 순서**로 구성됩니다.
이는 메서드 오버로딩(overloading) 가능 여부를를 구분하는 데 사용됩니다.

하나의 클래스에서 메서드 시그니처가 같은 메서드는 존재 할 수 없습니다.
메서드 시그니처가 동일한 경우 오버로딩 할 수 없습니다.
이 메서드 시그니처 룰은 함수형 인터페이스(SAM)의 메서드 매칭에는 사용되지 않습니다.

* 포함 항목:

  * 메서드 이름
  * 매개변수의 타입과 순서

* 포함되지 않는 항목:

  * 반환 타입
  * 예외 선언
  * 접근 제어자(public, private 등)

예를 들어, 다음 두 메서드는 시그니처가 동일하므로 오버로딩할 수 없습니다:

```java
int compute(int x);
void compute(int x); // 컴파일 오류: 시그니처가 동일함
```

이는 [Java 언어 명세 8.4.2 "Method Signature"](https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.2)에서 정의되어 있습니다.

---

### 오버로딩(Overloading)

같은 이름의 메서드를 **매개변수 목록(시그니처)**이 다르게 하여 여러 개 정의하는 것.

Table. 오버로딩의 규칙

| 규칙 항목 | 설명 |
| --------- | ---- |
| ✅ **메서드 이름은 같아야 함** | 반드시 동일한 이름을 사용해야 합니다. |
| ✅ **매개변수 타입, 개수, 순서 중 하나는 달라야 함** | 이것이 오버로딩을 구분하는 핵심 기준입니다. |
| ❌ **반환 타입(return type)은 오버로딩을 구분하지 못함** | 반환 타입만 다른 메서드는 오버로딩이 불가능합니다. |
| ❌ **접근 제어자(public 등)**, **예외 목록**, **매개변수 이름**은 무관 | 이들은 오버로딩 판별에 영향을 주지 않습니다. |

---

## 함수형 인터페이스에서의 추론 규칙

Java 8부터 도입된 **함수형 인터페이스**는 하나의 추상 메서드만을 가지는 인터페이스로, 람다 표현식이나 메서드 참조와 함께 사용됩니다. 컴파일러는 람다 표현식이나 메서드 참조가 함수형 인터페이스의 추상 메서드와 호환되는지 판단하기 위해 \*\*타입 추론(type inference)\*\*을 수행합니다.

### 추론 과정의 주요 기준

* **매개변수의 타입과 순서**
* **반환 타입**

이 과정에서 **메서드 이름은 고려되지 않습니다**.

예를 들어, 다음과 같은 함수형 인터페이스가 있을 때:

```java
@FunctionalInterface
interface Calculator {
    int compute(int a, int b);
}
```

다음과 같이 메서드 참조를 사용할 수 있습니다:

```java
public static int add(int x, int y) {
    return x + y;
}

Calculator calc = YourClass::add;
```

여기서 `add` 메서드의 이름은 `compute`와 다르지만, 매개변수의 타입과 순서, 반환 타입이 동일하므로 컴파일러는 이를 호환된다고 판단합니다.

이러한 추론 규칙은 Java 언어 명세 18장 "타입 추론(Type Inference)" 중 [18.5.3. Functional Interface Parameterization Inference ](https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html#jls-18.5.3)에서 상세히 설명되어 있습니다.

---

### JLS [18장 타입 추론(Type Inference)](https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html) 요약

#### 18.1 개념 및 표기법 (Concepts and Notation)

* **추론 변수(Inference Variables)**: 타입에 대한 메타 변수로, 타입 추론 과정에서 사용됩니다.
* **제약 조건 공식(Constraint Formulas)**: 타입 간의 호환성이나 서브타이핑 관계를 나타내는 공식입니다.
* **경계(Bounds)**: 타입 변수에 적용되는 상한 또는 하한 제한입니다.

#### 18.2 축소(Reduction)

* 복잡한 제약 조건을 더 단순한 형태로 변환하여 추론을 용이하게 합니다.

#### 18.3 통합(Incorporation)

* 여러 제약 조건을 통합하여 일관된 타입 추론을 수행합니다.

#### 18.4 해석(Resolution)

* 모든 제약 조건을 만족하는 구체적인 타입을 결정합니다.

#### 18.5 추론의 활용(Uses of Inference)

* 타입 추론이 실제로 적용되는 다양한 상황을 설명합니다.

  * **18.5.1 메서드 호출 가능성 추론(Invocation Applicability Inference)**: 메서드 호출이 가능한지 판단합니다.
  * **18.5.2 메서드 호출 타입 추론(Invocation Type Inference)**: 호출된 메서드의 반환 타입을 추론합니다.
  * **18.5.3 함수형 인터페이스 파라미터화 추론(Functional Interface Parameterization Inference)**: 람다 표현식이나 메서드 참조가 함수형 인터페이스와 호환되는지 판단합니다.
  * **18.5.4 더 구체적인 메서드 추론(More Specific Method Inference)**: 오버로딩된 메서드 중 더 구체적인 메서드를 선택합니다.